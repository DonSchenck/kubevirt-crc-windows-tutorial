Launch cluster and deploy KubeVirt
Wait for the Kubernetes cluster to be ready

Before we can start, we need to wait for the Kubernetes cluster to be ready (a command prompt will appear once it's ready).
Deploy KubeVirt

Deploy the KubeVirt operator[^1] using the latest KubeVirt version.

[^1] An Operator is a method of packaging, deploying and managing a Kubernetes application. A Kubernetes application is an application that is both deployed on Kubernetes and managed using the Kubernetes APIs and kubectl tooling. You can think of Operators as the runtime that manages this type of application on Kubernetes. If you want to learn more about Operators you can check the CoreOS Operators website: https://coreos.com/operators/

We query GitHub's API to get the latest available release (click on the text to autoexecute the commands on the console):


####
oc new-project mywindows

####
export KUBEVIRT_VERSION=$(curl -s https://api.github.com/repos/kubevirt/kubevirt/releases/latest | jq -r .tag_name) && echo $KUBEVIRT_VERSION



v0.25.0



Run the following command to deploy the KubeVirt Operator:

####
kubectl create -f https://github.com/kubevirt/kubevirt/releases/download/${KUBEVIRT_VERSION}/kubevirt-operator.yaml

This demo environment already runs within a virtualized environment, and in order to be able to run VMs here we need to pre-configure KubeVirt so it uses software-emulated virtualization instead of trying to use real hardware virtualization.

# kubectl create configmap kubevirt-config -n kubevirt --from-literal debug.useEmulation=true


####
oc apply -f set-config-map.yml




Now let's deploy KubeVirt by creating a Custom Resource that will trigger the 'operator' reaction and perform the deployment:

####
kubectl create -f https://github.com/kubevirt/kubevirt/releases/download/${KUBEVIRT_VERSION}/kubevirt-cr.yaml

Let's check the deployment:

####
kubectl get pods -n kubevirt



Once it's ready, it will show something similar to:

master $ kubectl get pods -n kubevirt
NAME                               READY     STATUS    RESTARTS   AGE
virt-api-7fc57db6dd-g4s4w          1/1       Running   0          3m
virt-api-7fc57db6dd-zd95q          1/1       Running   0          3m
virt-controller-6849d45bcc-88zd4   1/1       Running   0          3m
virt-controller-6849d45bcc-cmfzk   1/1       Running   0          3m
virt-handler-fvsqw                 1/1       Running   0          3m
virt-operator-5649f67475-gmphg     1/1       Running   0          4m
virt-operator-5649f67475-sw78k     1/1       Running   0          4m

Install Virtctl

virtctl is a client utility that helps interact with VM's (start/stop/console, etc):

wget -O virtctl https://github.com/kubevirt/kubevirt/releases/download/${KUBEVIRT_VERSION}/virtctl-${KUBEVIRT_VERSION}-linux-amd64

chmod +x virtctl

Now everything is ready to continue and launch a VM.





# Install Multus CNI stuff

cd /multus-CNI
cat ./images/multus-daemonset-pre-1.16.yml | kubectl apply -f -


# Create NAD

# run once




Create and use your first VM
Deploy a VM

oc create -f nad_brext.ORIGINAL.yml 

oc create -f summit2018_windows-template-runonce.yml



# install kubevirt networking operator

# Create cluster network addons






We are creating a Virtual Machine in the same way as we would create any other Kubernetes resource thanks to what KubeVirt has enabled in our environment. Now we have a Virtual Machine as a Kubernetes resource.

After the vm resource has been created, you can manage the VMs with standard 'kubectl' commands:

$ kubectl get vms
$ kubectl get vms -o yaml testvm

Check that the VM is defined (using commands above):

kubectl get vms

Notice from the output that the VM is not running yet.

To start a VM, virtctl should be used:

./virtctl start testvm

Alternatively you can use kubectl edit vm testvm to set .spec.running: true.

Now you can check again the VM status:

kubectl get vms

A VirtualMachine resource contains a VM's definition and status. An instance of a running VM has an additional associated resource, a VirtualMachineInstance.

Once the VM is running you can inspect its status:

$ kubectl get vmis
$ kubectl get vmis -o yaml testvm

kubectl get vmis

Once it's ready, the command above will print something like:

master $ kubectl get vmis
NAME      AGE       PHASE     IP           NODENAME
testvm    1m        Running   10.32.0.11   master

Accessing VMs (serial console & vnc)

Now that a VM is running you can access its serial console:

WARNING: in some browser environments you will not be able to escape the serial console on Katacoda.

NOTE: ^] means: press the "CTRL" and "]" keys to escape the console.

# Connect to the serial console
$ ./virtctl console testvm

If you opened the serial console within Katacoda and you can't escape from it by pressing ^], you can click on the + close to 'Terminal' to start a new shell there and be able to continue with the following steps in the shutdown and cleanup section.

In environments where VNC client access is available, the graphical console of a VM can be accessed with the virtctl vnc command.
Shutdown and cleanup

Shutting down a VM works by either using virtctl or editing the VM.

./virtctl stop testvm

Finally, the VM can be deleted using:

kubectl delete vms testvm







